{"ast":null,"code":"import Period from \"./period\";\nimport Lien from \"./lien\";\nimport House from \"./house\";\nimport { round } from \"../utils/NumberUtils\";\n\nclass Investor {\n  constructor({\n    investorInformation,\n    dealInformation,\n    renoInformation,\n    serviceType\n  }) {\n    const investmentCapital = investorInformation.investmentCapital,\n          secondaryMarket = investorInformation.secondaryMarket,\n          startDate = investorInformation.startDate,\n          passiveIncomeGoal = investorInformation.passiveIncomeGoal,\n          locations = investorInformation.locations,\n          lienCosts = investorInformation.lienCosts,\n          lienInterestRates = investorInformation.lienInterestRates,\n          netRentBreakdown = investorInformation.netRentBreakdown;\n    this.investmentCapital = investmentCapital;\n    this.secondaryMarket = secondaryMarket;\n    this.startDate = new Date(startDate);\n    this.startDate.setDate(1);\n    this.startDate.setHours(0);\n    this.startDate.setMinutes(0);\n    this.startDate.setSeconds(0);\n    this.startDate.setMilliseconds(0);\n    this.passiveIncomeGoal = passiveIncomeGoal;\n    this.netRentBreakdown = netRentBreakdown;\n    this.serviceType = serviceType;\n    this.investmentCycles = 0;\n    this.renoInformation = renoInformation;\n    this.dealInformation = dealInformation; //Merge in lien costs and interest rates\n\n    locations.forEach((location, index) => {\n      location.avgLienCostLiveAuction = lienCosts[index].avgLienCostLiveAuction;\n      location.avgLienCostSecondary = lienCosts[index].avgLienCostSecondary;\n      location.avgLienInterestRate = lienInterestRates[index];\n    }); //Get rid of default locations.\n\n    this.locations = locations.filter(location => location.abbreviation !== \"DEFAULT\");\n    this.mostRecentLienPurchaseDate = null;\n    this.periods = [];\n    this.houses = [];\n    this.liens = [];\n    this.passiveIncome = [];\n  }\n\n  simulate() {\n    //Run a month-by-month simulation based on the investor's inupts.\n    return new Promise((resolve, reject) => {\n      let monthIndex = 0;\n      let possiblePassiveIncome = 0;\n\n      while (possiblePassiveIncome < this.passiveIncomeGoal && monthIndex < 360) {\n        let date = new Date(this.startDate);\n        date.setMonth(this.startDate.getMonth() + monthIndex);\n        this.simulateMonth(date);\n        const lastPeriod = this.periods[this.periods.length - 1];\n        possiblePassiveIncome = lastPeriod.rentBreakdown.totalNetRent - lastPeriod.requiredDebtPayment;\n        monthIndex++;\n      } // this.liens.forEach(lien => {\n      //   console.log(\n      //     this.printDate(lien.purchaseDate, \"LP\"),\n      //     this.printDate(lien.redemptionDate, \"RD\"),\n      //     this.printDate(lien.foreclosureStartDate, \"FS\"),\n      //     this.printDate(lien.foreclosureEndDate, \"FE\"),\n      //     this.printDate(lien.adminStartDate, \"AS\"),\n      //     this.printDate(lien.adminEndDate, \"AE\"),\n      //     this.printDate(lien.becomeHouseDate, \"BH\")\n      //   );\n      // });\n\n\n      if (this.periods) resolve(this.periods);\n      reject({\n        msg: \"There was an error simulating periods.\"\n      });\n    });\n  }\n\n  printDate(date, prefix = \"?\") {\n    if (!date) return prefix + \": \" + null;\n    return prefix + \": \" + date.toLocaleDateString(\"en-US\", {\n      year: \"numeric\",\n      month: \"short\"\n    });\n  }\n\n  simulateMonth(date) {\n    // Generate the Period.\n    let period = new Period(date, this.investmentCapital);\n    this.periods.push(period); // Purchase Liens\n\n    this.attemptToPurchaseLiens(period); // Pay for foreclosures\n\n    this.payForeclosures(period); // Process Redemptions\n\n    this.processCertificates(period); //Pay Loans\n\n    this.makeRequiredLoanPayments(period); // Receive & Allocate Rent\n\n    this.processRent(period); //Update house count\n\n    period.setTotalHouseCount(this.houses.length);\n  }\n\n  attemptToPurchaseLiens(period) {\n    // Are there any for sale?\n    const location = this.getPurchaseLocation();\n    if (!location) return null; // If Secondary, are you rate-limited\n    // from buying this time around.\n\n    if (this.secondaryMarket && this.mostRecentLienPurchaseDate) {\n      // Have bought liens, make sure enough time has passed so\n      // we can buy again. (time for research to be conducted)\n      const nextAllowedBuyDate = new Date(this.mostRecentLienPurchaseDate);\n      nextAllowedBuyDate.setMonth(nextAllowedBuyDate.getMonth() + 2);\n      if (nextAllowedBuyDate > period.date) return null;\n    } // How many can the investor afford?\n\n\n    const _this$getMaxNumLiensC = this.getMaxNumLiensCanAfford(location),\n          qty = _this$getMaxNumLiensC.qty,\n          costPerLien = _this$getMaxNumLiensC.costPerLien,\n          fee = _this$getMaxNumLiensC.fee;\n\n    if (qty > 0) {\n      // Build plan for buying Liens.\n      const lienPurchasePlan = {\n        qty,\n        costPerLien,\n        fee,\n        location,\n        secondaryMarket: this.secondaryMarket\n      };\n      period.setPurchasePlan(lienPurchasePlan);\n      this.investmentCycles++;\n      this.mostRecentLienPurchaseMonth = period.date;\n      this.purchaseLiens(lienPurchasePlan, period.date);\n    }\n  }\n\n  getPurchaseLocation() {\n    // Secondary: Can always buy on the secondary market, pick location at random.\n    if (this.secondaryMarket) {\n      const options = this.locations.length;\n      const randLocation = Math.floor((Math.random() - 0.0001) * options);\n      return this.locations[randLocation];\n    } // Live Auction: Check for available auctions and take one with higest priority.\n\n\n    const monthIndex = this.periods[this.periods.length - 1].date.getMonth();\n\n    for (let i = 0; i < this.locations.length; i++) {\n      if (this.locations[i].liveAuctionMonths[monthIndex]) {\n        return this.locations[i]; //return first location that matches.\n      }\n    }\n\n    return null;\n  }\n\n  getMaxNumLiensCanAfford(location) {\n    // Investor has to have enough money to cover lien costs\n    // and fees according to following rules.\n    // 1. Have to buy in multiples of redemption ratio.\n    // 2. Have to be able to pay fee according to schedule.\n    //    a. Purchasing from Secondary\n    //       --First Cycle: $10,000 plus 10% of lien purchase total\n    //       --2nd Cycle Onward: 10% of lien purchase total\n    //    b. Live Auction\n    //       --Setup: $10,000 first cycle\n    //         --First Cycle: $10,000\n    //         --2nd Cycle Onward: $0\n    //       --Recurring:\n    //         --First Cycle: $10,000\n    //         --2nd Cycle Onward: $8,000\n    const redemptionRatio = this.dealInformation.redemptionRatio;\n    let costPerLien = this.getCostPerLien(location);\n    let hasMoney = true;\n    let multipleToBuy = 1;\n    let qty = 0;\n    let lienCost = 0;\n    let fee = 0;\n    let planCost = 0; //Loop through to get the maximum number of liens\n    //the investor can afford to buy at this time.\n\n    while (hasMoney) {\n      if (this.secondaryMarket) {\n        if (this.investmentCycles === 0) {\n          //Secondary: First Cycle\n          qty = redemptionRatio * multipleToBuy;\n          lienCost = costPerLien * qty;\n          fee = 10000 + lienCost * 0.1;\n          planCost = lienCost + fee;\n\n          if (planCost > this.investmentCapital) {\n            hasMoney = false;\n            qty = redemptionRatio * (multipleToBuy - 1);\n            lienCost = costPerLien * qty;\n            fee = lienCost ? 10000 + lienCost * 0.1 : 0;\n            planCost = lienCost + fee;\n          } else {\n            multipleToBuy++;\n          }\n        } else {\n          //Secondary: 2nd Cycle Onward\n          qty = redemptionRatio * multipleToBuy;\n          lienCost = costPerLien * qty;\n          fee = lienCost * 0.1;\n          planCost = lienCost + fee;\n\n          if (planCost > this.investmentCapital) {\n            hasMoney = false;\n            qty = redemptionRatio * (multipleToBuy - 1);\n            lienCost = costPerLien * qty;\n            fee = lienCost ? lienCost * 0.1 : 0;\n            planCost = lienCost + fee;\n          } else {\n            multipleToBuy++;\n          }\n        }\n      } else {\n        if (this.serviceType.setup) {\n          if (this.investmentCycles === 0) {\n            // Setup: First Cycle\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 10000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 10000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          } else {\n            // Setup: 2nd Cycle Onward\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 0;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          }\n        } else if (this.serviceType.recurring) {\n          if (this.investmentCycles === 0) {\n            // First time recurring. Has fee.\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 10000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 10000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          } else {\n            // Second time recurring. Discounted Fee\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 8000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 8000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      qty,\n      costPerLien,\n      fee\n    };\n  }\n\n  getCostPerLien(location) {\n    if (this.secondaryMarket) {\n      return location.avgLienCostSecondary;\n    } else {\n      return location.avgLienCostLiveAuction;\n    }\n  }\n\n  purchaseLiens(lienPurchasePlan, date) {\n    // Deduct cycle fee\n    this.investmentCapital -= lienPurchasePlan.fee;\n    const houseQty = Math.floor(lienPurchasePlan.qty / this.dealInformation.redemptionRatio);\n    const nonHouseQty = lienPurchasePlan.qty - houseQty;\n    let nonHouseCounter = 0;\n\n    for (let i = 1; i <= lienPurchasePlan.qty; i++) {\n      const willBecomeHouse = i % this.dealInformation.redemptionRatio === 0;\n      let nonHousePct = 0;\n\n      if (!willBecomeHouse) {\n        nonHouseCounter++;\n        nonHousePct = nonHouseCounter / nonHouseQty;\n      }\n\n      let lien = new Lien(date, this.investmentCycles, lienPurchasePlan, willBecomeHouse, nonHousePct);\n      this.liens.push(lien); // Deduct lien cost\n\n      this.investmentCapital -= lienPurchasePlan.costPerLien;\n    }\n  }\n\n  payForeclosures(period) {\n    const curMonth = period.date.getMonth();\n    const curYear = period.date.getYear();\n    const liensStartingForeclosure = this.liens.filter(lien => !lien.foreclosureStartDate ? false : lien.foreclosureStartDate.getMonth() === curMonth && lien.foreclosureStartDate.getYear() === curYear && lien.foreclosureStartDate < lien.redemptionDate);\n    liensStartingForeclosure.forEach(lien => {\n      this.investmentCapital -= lien.location.foreclosureCost;\n      period.updateForeclosureCost(lien.location.foreclosureCost);\n    });\n  }\n\n  processCertificates(period) {\n    // We assume liens that do not become houses\n    // pay their investors back according to the following\n    // scenarios:\n    //\n    // 1. If 'next' March is before foreclosure and\n    //    Foreclosure included in redemption:\n    //    a. 1/3 Following March\n    //    b. 1/3 End Redemption\n    //    c. 1/3 End Foreclosure\n    //\n    // 2. If 'next' March is before redemption and\n    //    Foreclsoure not included in redemption\n    //    a. 1/3 Following March\n    //    b. 2/3 End Redemption\n    //\n    // 3. If 'next' March is after foreclosure and\n    //    Foreclosure included in redemption:\n    //    a. 1/3 End redemption\n    //    b. 2/3 End foreclosure\n    //\n    // 4. If 'next' March is after redemption and\n    //    Foreclsoure not included in redemption\n    //    a. All End redemption\n    const curMonth = period.date.getMonth();\n    const curYear = period.date.getYear();\n    const allRedeemLiens = this.liens.filter(lien => !lien.willBecomeHouse);\n    const allHouseLiens = this.liens.filter(lien => lien.willBecomeHouse);\n    const curLiensToRedeem = allRedeemLiens.filter(lien => lien.redemptionDate.getMonth() === curMonth && lien.redemptionDate.getYear() === curYear);\n    const curLiensToBecomeHouses = allHouseLiens.filter(lien => lien.becomeHouseDate.getMonth() === curMonth && lien.becomeHouseDate.getYear() === curYear);\n    curLiensToRedeem.forEach(lien => {\n      const redemptionIncome = lien.calculateRedemptionIncome();\n      this.investmentCapital += redemptionIncome;\n      period.updateRedemptionIncome(redemptionIncome);\n    });\n    curLiensToBecomeHouses.forEach(lien => {\n      let house = new House(lien, this.renoInformation, this.dealInformation);\n      this.houses.push(house);\n    });\n  }\n\n  makeRequiredLoanPayments(period) {\n    const housesWithLoans = this.houses.filter(house => period.date >= house.renoStartDate && house.loan.balance > 0);\n    let totalPayment = 0;\n    let totalLoanBalance = 0;\n    housesWithLoans.forEach(house => {\n      const minPayment = house.loan.getMinPayment();\n      house.loan.makePayment(minPayment);\n      totalPayment += minPayment;\n      totalLoanBalance += house.loan.getBalance();\n    });\n    period.setRequiedDebtPayment(totalPayment);\n    period.setTotalLoanBalance(totalLoanBalance);\n    this.investmentCapital -= totalPayment;\n  }\n\n  makeExtraLoanPayments(period, amt) {\n    const housesWithLoans = this.houses.filter(house => house.renoStartDate <= period.date && house.loan.balance > 0);\n    const amtPerHouse = amt / housesWithLoans.length;\n    let totalPayment = 0;\n    housesWithLoans.forEach(house => {\n      house.loan.makePrincipalPayment(amtPerHouse);\n      totalPayment += amtPerHouse;\n    });\n    period.setExtraDebtPayment(totalPayment); // We don't reduce investment capital here,\n    // Because this is coming out of collected rent\n    // money.\n  }\n\n  processRent(period) {\n    const housesRentedOut = this.houses.filter(house => house.rentStartDate <= period.date);\n    let rentBreakdown = {\n      totalGrossRent: 0,\n      totalNetRent: 0,\n      totalExpenses: 0,\n      totalManagement: 0,\n      totalVacancy: 0,\n      totalRepair: 0\n    };\n    housesRentedOut.forEach(house => {\n      const _house$collectRent = house.collectRent(),\n            grossRent = _house$collectRent.grossRent,\n            totalExpenses = _house$collectRent.totalExpenses,\n            netRent = _house$collectRent.netRent,\n            management = _house$collectRent.management,\n            vacancy = _house$collectRent.vacancy,\n            repair = _house$collectRent.repair;\n\n      rentBreakdown.totalGrossRent += grossRent;\n      rentBreakdown.totalExpenses += totalExpenses;\n      rentBreakdown.totalNetRent += netRent;\n      rentBreakdown.totalManagement += management;\n      rentBreakdown.totalVacancy += vacancy;\n      rentBreakdown.totalRepair += repair;\n    });\n    period.setRentBreakdown(rentBreakdown); // Allocate the net rent (net rent = rent less mgmt, vacancy, & repair)\n\n    this.allocateRent(period);\n  }\n\n  allocateRent(period) {\n    const totalNetRent = period.rentBreakdown.totalNetRent;\n    const netRentLessDebt = totalNetRent - period.requiredDebtPayment;\n    if (totalNetRent === 0) return;\n\n    if (period.requiredDebtPayment > 0) {\n      // We made debt payment this period\n      // set aside required debt payment funds from\n      // the rent money back to investment capital.\n      // Note: the makeRequiredLoanPayments() method already\n      // paid these from our capital.\n      this.investmentCapital += period.requiredDebtPayment;\n    }\n\n    if (netRentLessDebt < 0) {\n      // Rent cash-flow is negative, this should be\n      // shown as negative passive income\n      period.setPassiveIncome(round(netRentLessDebt, 2));\n    } else {\n      // Rent cash-flow is positive allocate the money\n      // according to goals and preferences.\n      const _this$netRentBreakdow = this.netRentBreakdown,\n            spendPct = _this$netRentBreakdow.spendPct,\n            paydownDebtPct = _this$netRentBreakdow.paydownDebtPct,\n            reinvestPct = _this$netRentBreakdow.reinvestPct;\n\n      if (netRentLessDebt >= this.passiveIncomeGoal) {\n        //Investor has met goal. All money goes to passive income goal.\n        period.setPassiveIncome(round(netRentLessDebt, 2));\n      } else {\n        //Investor has not met goal, allocate according to preferences.\n        //1. Increase Investment Capital\n        if (reinvestPct > 0) {\n          const reinvestAmt = round(netRentLessDebt * reinvestPct / 100, 2);\n          period.setRentReinvested(reinvestAmt);\n          this.investmentCapital += reinvestAmt;\n        } //2. Increase Passive Income\n\n\n        if (spendPct > 0) {\n          const passiveIncome = round(netRentLessDebt * spendPct / 100, 2);\n          period.setPassiveIncome(passiveIncome);\n        } //3. Decrease outstanding debt on houses.\n\n\n        if (paydownDebtPct > 0) {\n          const extraPaymentAmt = round(netRentLessDebt * paydownDebtPct / 100, 2);\n\n          if (period.requiredDebtPayment === 0) {\n            // All loans are paid. Add money to reinvestment income instead.\n            period.setRentReinvested(period.rentReinvested + extraPaymentAmt);\n          } else {\n            //Still have loans, apply extra payments to them\n            this.makeExtraLoanPayments(period, extraPaymentAmt);\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexport default Investor;","map":{"version":3,"sources":["/Users/reappdev/repos/iwealth-tax-lien-calculator/src/models/investor.jsx"],"names":["Period","Lien","House","round","Investor","constructor","investorInformation","dealInformation","renoInformation","serviceType","investmentCapital","secondaryMarket","startDate","passiveIncomeGoal","locations","lienCosts","lienInterestRates","netRentBreakdown","Date","setDate","setHours","setMinutes","setSeconds","setMilliseconds","investmentCycles","forEach","location","index","avgLienCostLiveAuction","avgLienCostSecondary","avgLienInterestRate","filter","abbreviation","mostRecentLienPurchaseDate","periods","houses","liens","passiveIncome","simulate","Promise","resolve","reject","monthIndex","possiblePassiveIncome","date","setMonth","getMonth","simulateMonth","lastPeriod","length","rentBreakdown","totalNetRent","requiredDebtPayment","msg","printDate","prefix","toLocaleDateString","year","month","period","push","attemptToPurchaseLiens","payForeclosures","processCertificates","makeRequiredLoanPayments","processRent","setTotalHouseCount","getPurchaseLocation","nextAllowedBuyDate","getMaxNumLiensCanAfford","qty","costPerLien","fee","lienPurchasePlan","setPurchasePlan","mostRecentLienPurchaseMonth","purchaseLiens","options","randLocation","Math","floor","random","i","liveAuctionMonths","redemptionRatio","getCostPerLien","hasMoney","multipleToBuy","lienCost","planCost","setup","recurring","houseQty","nonHouseQty","nonHouseCounter","willBecomeHouse","nonHousePct","lien","curMonth","curYear","getYear","liensStartingForeclosure","foreclosureStartDate","redemptionDate","foreclosureCost","updateForeclosureCost","allRedeemLiens","allHouseLiens","curLiensToRedeem","curLiensToBecomeHouses","becomeHouseDate","redemptionIncome","calculateRedemptionIncome","updateRedemptionIncome","house","housesWithLoans","renoStartDate","loan","balance","totalPayment","totalLoanBalance","minPayment","getMinPayment","makePayment","getBalance","setRequiedDebtPayment","setTotalLoanBalance","makeExtraLoanPayments","amt","amtPerHouse","makePrincipalPayment","setExtraDebtPayment","housesRentedOut","rentStartDate","totalGrossRent","totalExpenses","totalManagement","totalVacancy","totalRepair","collectRent","grossRent","netRent","management","vacancy","repair","setRentBreakdown","allocateRent","netRentLessDebt","setPassiveIncome","spendPct","paydownDebtPct","reinvestPct","reinvestAmt","setRentReinvested","extraPaymentAmt","rentReinvested"],"mappings":"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","sourcesContent":["import Period from \"./period\";\nimport Lien from \"./lien\";\nimport House from \"./house\";\nimport { round } from \"../utils/NumberUtils\";\n\nclass Investor {\n  constructor({\n    investorInformation,\n    dealInformation,\n    renoInformation,\n    serviceType\n  }) {\n    const {\n      investmentCapital,\n      secondaryMarket,\n      startDate,\n      passiveIncomeGoal,\n      locations,\n      lienCosts,\n      lienInterestRates,\n      netRentBreakdown\n    } = investorInformation;\n\n    this.investmentCapital = investmentCapital;\n    this.secondaryMarket = secondaryMarket;\n    this.startDate = new Date(startDate);\n    this.startDate.setDate(1);\n    this.startDate.setHours(0);\n    this.startDate.setMinutes(0);\n    this.startDate.setSeconds(0);\n    this.startDate.setMilliseconds(0);\n    this.passiveIncomeGoal = passiveIncomeGoal;\n    this.netRentBreakdown = netRentBreakdown;\n    this.serviceType = serviceType;\n    this.investmentCycles = 0;\n    this.renoInformation = renoInformation;\n    this.dealInformation = dealInformation;\n\n    //Merge in lien costs and interest rates\n    locations.forEach((location, index) => {\n      location.avgLienCostLiveAuction = lienCosts[index].avgLienCostLiveAuction;\n      location.avgLienCostSecondary = lienCosts[index].avgLienCostSecondary;\n      location.avgLienInterestRate = lienInterestRates[index];\n    });\n\n    //Get rid of default locations.\n    this.locations = locations.filter(\n      location => location.abbreviation !== \"DEFAULT\"\n    );\n\n    this.mostRecentLienPurchaseDate = null;\n\n    this.periods = [];\n    this.houses = [];\n    this.liens = [];\n    this.passiveIncome = [];\n  }\n\n  simulate() {\n    //Run a month-by-month simulation based on the investor's inupts.\n    return new Promise((resolve, reject) => {\n      let monthIndex = 0;\n      let possiblePassiveIncome = 0;\n\n      while (\n        possiblePassiveIncome < this.passiveIncomeGoal &&\n        monthIndex < 360\n      ) {\n        let date = new Date(this.startDate);\n        date.setMonth(this.startDate.getMonth() + monthIndex);\n        this.simulateMonth(date);\n        const lastPeriod = this.periods[this.periods.length - 1];\n\n        possiblePassiveIncome =\n          lastPeriod.rentBreakdown.totalNetRent -\n          lastPeriod.requiredDebtPayment;\n        monthIndex++;\n      }\n\n      // this.liens.forEach(lien => {\n      //   console.log(\n      //     this.printDate(lien.purchaseDate, \"LP\"),\n      //     this.printDate(lien.redemptionDate, \"RD\"),\n      //     this.printDate(lien.foreclosureStartDate, \"FS\"),\n      //     this.printDate(lien.foreclosureEndDate, \"FE\"),\n      //     this.printDate(lien.adminStartDate, \"AS\"),\n      //     this.printDate(lien.adminEndDate, \"AE\"),\n      //     this.printDate(lien.becomeHouseDate, \"BH\")\n      //   );\n      // });\n\n      if (this.periods) resolve(this.periods);\n      reject({ msg: \"There was an error simulating periods.\" });\n    });\n  }\n\n  printDate(date, prefix = \"?\") {\n    if (!date) return prefix + \": \" + null;\n    return (\n      prefix +\n      \": \" +\n      date.toLocaleDateString(\"en-US\", {\n        year: \"numeric\",\n        month: \"short\"\n      })\n    );\n  }\n\n  simulateMonth(date) {\n    // Generate the Period.\n    let period = new Period(date, this.investmentCapital);\n    this.periods.push(period);\n\n    // Purchase Liens\n    this.attemptToPurchaseLiens(period);\n\n    // Pay for foreclosures\n    this.payForeclosures(period);\n\n    // Process Redemptions\n    this.processCertificates(period);\n\n    //Pay Loans\n    this.makeRequiredLoanPayments(period);\n\n    // Receive & Allocate Rent\n    this.processRent(period);\n\n    //Update house count\n    period.setTotalHouseCount(this.houses.length);\n  }\n\n  attemptToPurchaseLiens(period) {\n    // Are there any for sale?\n    const location = this.getPurchaseLocation();\n    if (!location) return null;\n\n    // If Secondary, are you rate-limited\n    // from buying this time around.\n    if (this.secondaryMarket && this.mostRecentLienPurchaseDate) {\n      // Have bought liens, make sure enough time has passed so\n      // we can buy again. (time for research to be conducted)\n      const nextAllowedBuyDate = new Date(this.mostRecentLienPurchaseDate);\n      nextAllowedBuyDate.setMonth(nextAllowedBuyDate.getMonth() + 2);\n      if (nextAllowedBuyDate > period.date) return null;\n    }\n\n    // How many can the investor afford?\n    const { qty, costPerLien, fee } = this.getMaxNumLiensCanAfford(location);\n\n    if (qty > 0) {\n      // Build plan for buying Liens.\n      const lienPurchasePlan = {\n        qty,\n        costPerLien,\n        fee,\n        location,\n        secondaryMarket: this.secondaryMarket\n      };\n\n      period.setPurchasePlan(lienPurchasePlan);\n      this.investmentCycles++;\n      this.mostRecentLienPurchaseMonth = period.date;\n      this.purchaseLiens(lienPurchasePlan, period.date);\n    }\n  }\n\n  getPurchaseLocation() {\n    // Secondary: Can always buy on the secondary market, pick location at random.\n    if (this.secondaryMarket) {\n      const options = this.locations.length;\n      const randLocation = Math.floor((Math.random() - 0.0001) * options);\n      return this.locations[randLocation];\n    }\n\n    // Live Auction: Check for available auctions and take one with higest priority.\n    const monthIndex = this.periods[this.periods.length - 1].date.getMonth();\n    for (let i = 0; i < this.locations.length; i++) {\n      if (this.locations[i].liveAuctionMonths[monthIndex]) {\n        return this.locations[i]; //return first location that matches.\n      }\n    }\n\n    return null;\n  }\n\n  getMaxNumLiensCanAfford(location) {\n    // Investor has to have enough money to cover lien costs\n    // and fees according to following rules.\n    // 1. Have to buy in multiples of redemption ratio.\n    // 2. Have to be able to pay fee according to schedule.\n    //    a. Purchasing from Secondary\n    //       --First Cycle: $10,000 plus 10% of lien purchase total\n    //       --2nd Cycle Onward: 10% of lien purchase total\n    //    b. Live Auction\n    //       --Setup: $10,000 first cycle\n    //         --First Cycle: $10,000\n    //         --2nd Cycle Onward: $0\n    //       --Recurring:\n    //         --First Cycle: $10,000\n    //         --2nd Cycle Onward: $8,000\n\n    const redemptionRatio = this.dealInformation.redemptionRatio;\n    let costPerLien = this.getCostPerLien(location);\n\n    let hasMoney = true;\n    let multipleToBuy = 1;\n    let qty = 0;\n    let lienCost = 0;\n    let fee = 0;\n    let planCost = 0;\n\n    //Loop through to get the maximum number of liens\n    //the investor can afford to buy at this time.\n    while (hasMoney) {\n      if (this.secondaryMarket) {\n        if (this.investmentCycles === 0) {\n          //Secondary: First Cycle\n          qty = redemptionRatio * multipleToBuy;\n          lienCost = costPerLien * qty;\n          fee = 10000 + lienCost * 0.1;\n          planCost = lienCost + fee;\n\n          if (planCost > this.investmentCapital) {\n            hasMoney = false;\n            qty = redemptionRatio * (multipleToBuy - 1);\n            lienCost = costPerLien * qty;\n            fee = lienCost ? 10000 + lienCost * 0.1 : 0;\n            planCost = lienCost + fee;\n          } else {\n            multipleToBuy++;\n          }\n        } else {\n          //Secondary: 2nd Cycle Onward\n          qty = redemptionRatio * multipleToBuy;\n          lienCost = costPerLien * qty;\n          fee = lienCost * 0.1;\n          planCost = lienCost + fee;\n\n          if (planCost > this.investmentCapital) {\n            hasMoney = false;\n            qty = redemptionRatio * (multipleToBuy - 1);\n            lienCost = costPerLien * qty;\n            fee = lienCost ? lienCost * 0.1 : 0;\n            planCost = lienCost + fee;\n          } else {\n            multipleToBuy++;\n          }\n        }\n      } else {\n        if (this.serviceType.setup) {\n          if (this.investmentCycles === 0) {\n            // Setup: First Cycle\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 10000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 10000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          } else {\n            // Setup: 2nd Cycle Onward\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 0;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          }\n        } else if (this.serviceType.recurring) {\n          if (this.investmentCycles === 0) {\n            // First time recurring. Has fee.\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 10000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 10000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          } else {\n            // Second time recurring. Discounted Fee\n            qty = redemptionRatio * multipleToBuy;\n            lienCost = costPerLien * qty;\n            fee = 8000;\n            planCost = lienCost + fee;\n\n            if (planCost > this.investmentCapital) {\n              hasMoney = false;\n              qty = redemptionRatio * (multipleToBuy - 1);\n              lienCost = costPerLien * qty;\n              fee = lienCost ? 8000 : 0;\n              planCost = lienCost + fee;\n            } else {\n              multipleToBuy++;\n            }\n          }\n        }\n      }\n    }\n\n    return { qty, costPerLien, fee };\n  }\n\n  getCostPerLien(location) {\n    if (this.secondaryMarket) {\n      return location.avgLienCostSecondary;\n    } else {\n      return location.avgLienCostLiveAuction;\n    }\n  }\n\n  purchaseLiens(lienPurchasePlan, date) {\n    // Deduct cycle fee\n    this.investmentCapital -= lienPurchasePlan.fee;\n\n    const houseQty = Math.floor(\n      lienPurchasePlan.qty / this.dealInformation.redemptionRatio\n    );\n    const nonHouseQty = lienPurchasePlan.qty - houseQty;\n    let nonHouseCounter = 0;\n\n    for (let i = 1; i <= lienPurchasePlan.qty; i++) {\n      const willBecomeHouse = i % this.dealInformation.redemptionRatio === 0;\n\n      let nonHousePct = 0;\n      if (!willBecomeHouse) {\n        nonHouseCounter++;\n        nonHousePct = nonHouseCounter / nonHouseQty;\n      }\n\n      let lien = new Lien(\n        date,\n        this.investmentCycles,\n        lienPurchasePlan,\n        willBecomeHouse,\n        nonHousePct\n      );\n\n      this.liens.push(lien);\n      // Deduct lien cost\n      this.investmentCapital -= lienPurchasePlan.costPerLien;\n    }\n  }\n\n  payForeclosures(period) {\n    const curMonth = period.date.getMonth();\n    const curYear = period.date.getYear();\n\n    const liensStartingForeclosure = this.liens.filter(lien =>\n      !lien.foreclosureStartDate\n        ? false\n        : lien.foreclosureStartDate.getMonth() === curMonth &&\n          lien.foreclosureStartDate.getYear() === curYear &&\n          lien.foreclosureStartDate < lien.redemptionDate\n    );\n\n    liensStartingForeclosure.forEach(lien => {\n      this.investmentCapital -= lien.location.foreclosureCost;\n      period.updateForeclosureCost(lien.location.foreclosureCost);\n    });\n  }\n\n  processCertificates(period) {\n    // We assume liens that do not become houses\n    // pay their investors back according to the following\n    // scenarios:\n    //\n    // 1. If 'next' March is before foreclosure and\n    //    Foreclosure included in redemption:\n    //    a. 1/3 Following March\n    //    b. 1/3 End Redemption\n    //    c. 1/3 End Foreclosure\n    //\n    // 2. If 'next' March is before redemption and\n    //    Foreclsoure not included in redemption\n    //    a. 1/3 Following March\n    //    b. 2/3 End Redemption\n    //\n    // 3. If 'next' March is after foreclosure and\n    //    Foreclosure included in redemption:\n    //    a. 1/3 End redemption\n    //    b. 2/3 End foreclosure\n    //\n    // 4. If 'next' March is after redemption and\n    //    Foreclsoure not included in redemption\n    //    a. All End redemption\n\n    const curMonth = period.date.getMonth();\n    const curYear = period.date.getYear();\n\n    const allRedeemLiens = this.liens.filter(lien => !lien.willBecomeHouse);\n    const allHouseLiens = this.liens.filter(lien => lien.willBecomeHouse);\n\n    const curLiensToRedeem = allRedeemLiens.filter(\n      lien =>\n        lien.redemptionDate.getMonth() === curMonth &&\n        lien.redemptionDate.getYear() === curYear\n    );\n\n    const curLiensToBecomeHouses = allHouseLiens.filter(\n      lien =>\n        lien.becomeHouseDate.getMonth() === curMonth &&\n        lien.becomeHouseDate.getYear() === curYear\n    );\n\n    curLiensToRedeem.forEach(lien => {\n      const redemptionIncome = lien.calculateRedemptionIncome();\n      this.investmentCapital += redemptionIncome;\n      period.updateRedemptionIncome(redemptionIncome);\n    });\n\n    curLiensToBecomeHouses.forEach(lien => {\n      let house = new House(lien, this.renoInformation, this.dealInformation);\n      this.houses.push(house);\n    });\n  }\n\n  makeRequiredLoanPayments(period) {\n    const housesWithLoans = this.houses.filter(\n      house => period.date >= house.renoStartDate && house.loan.balance > 0\n    );\n\n    let totalPayment = 0;\n    let totalLoanBalance = 0;\n    housesWithLoans.forEach(house => {\n      const minPayment = house.loan.getMinPayment();\n      house.loan.makePayment(minPayment);\n      totalPayment += minPayment;\n      totalLoanBalance += house.loan.getBalance();\n    });\n\n    period.setRequiedDebtPayment(totalPayment);\n    period.setTotalLoanBalance(totalLoanBalance);\n\n    this.investmentCapital -= totalPayment;\n  }\n\n  makeExtraLoanPayments(period, amt) {\n    const housesWithLoans = this.houses.filter(\n      house => house.renoStartDate <= period.date && house.loan.balance > 0\n    );\n\n    const amtPerHouse = amt / housesWithLoans.length;\n\n    let totalPayment = 0;\n    housesWithLoans.forEach(house => {\n      house.loan.makePrincipalPayment(amtPerHouse);\n      totalPayment += amtPerHouse;\n    });\n\n    period.setExtraDebtPayment(totalPayment);\n\n    // We don't reduce investment capital here,\n    // Because this is coming out of collected rent\n    // money.\n  }\n\n  processRent(period) {\n    const housesRentedOut = this.houses.filter(\n      house => house.rentStartDate <= period.date\n    );\n\n    let rentBreakdown = {\n      totalGrossRent: 0,\n      totalNetRent: 0,\n      totalExpenses: 0,\n      totalManagement: 0,\n      totalVacancy: 0,\n      totalRepair: 0\n    };\n\n    housesRentedOut.forEach(house => {\n      const {\n        grossRent,\n        totalExpenses,\n        netRent,\n        management,\n        vacancy,\n        repair\n      } = house.collectRent();\n      rentBreakdown.totalGrossRent += grossRent;\n      rentBreakdown.totalExpenses += totalExpenses;\n      rentBreakdown.totalNetRent += netRent;\n      rentBreakdown.totalManagement += management;\n      rentBreakdown.totalVacancy += vacancy;\n      rentBreakdown.totalRepair += repair;\n    });\n\n    period.setRentBreakdown(rentBreakdown);\n\n    // Allocate the net rent (net rent = rent less mgmt, vacancy, & repair)\n    this.allocateRent(period);\n  }\n\n  allocateRent(period) {\n    const { totalNetRent } = period.rentBreakdown;\n    const netRentLessDebt = totalNetRent - period.requiredDebtPayment;\n\n    if (totalNetRent === 0) return;\n\n    if (period.requiredDebtPayment > 0) {\n      // We made debt payment this period\n      // set aside required debt payment funds from\n      // the rent money back to investment capital.\n      // Note: the makeRequiredLoanPayments() method already\n      // paid these from our capital.\n      this.investmentCapital += period.requiredDebtPayment;\n    }\n\n    if (netRentLessDebt < 0) {\n      // Rent cash-flow is negative, this should be\n      // shown as negative passive income\n      period.setPassiveIncome(round(netRentLessDebt, 2));\n    } else {\n      // Rent cash-flow is positive allocate the money\n      // according to goals and preferences.\n\n      const { spendPct, paydownDebtPct, reinvestPct } = this.netRentBreakdown;\n\n      if (netRentLessDebt >= this.passiveIncomeGoal) {\n        //Investor has met goal. All money goes to passive income goal.\n        period.setPassiveIncome(round(netRentLessDebt, 2));\n      } else {\n        //Investor has not met goal, allocate according to preferences.\n\n        //1. Increase Investment Capital\n        if (reinvestPct > 0) {\n          const reinvestAmt = round((netRentLessDebt * reinvestPct) / 100, 2);\n          period.setRentReinvested(reinvestAmt);\n          this.investmentCapital += reinvestAmt;\n        }\n\n        //2. Increase Passive Income\n        if (spendPct > 0) {\n          const passiveIncome = round((netRentLessDebt * spendPct) / 100, 2);\n          period.setPassiveIncome(passiveIncome);\n        }\n\n        //3. Decrease outstanding debt on houses.\n        if (paydownDebtPct > 0) {\n          const extraPaymentAmt = round(\n            (netRentLessDebt * paydownDebtPct) / 100,\n            2\n          );\n\n          if (period.requiredDebtPayment === 0) {\n            // All loans are paid. Add money to reinvestment income instead.\n            period.setRentReinvested(period.rentReinvested + extraPaymentAmt);\n          } else {\n            //Still have loans, apply extra payments to them\n            this.makeExtraLoanPayments(period, extraPaymentAmt);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default Investor;\n"]},"metadata":{},"sourceType":"module"}